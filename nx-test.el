(require 'nx)
(require 'ert)

(defun nx-test-equal (a b)
  "Custom equality predicate for nx nodes in tests."
  (cond
   ((and (hash-table-p a) (hash-table-p b))
    (nx--node-equal a b))
   ((and (listp a) (listp b))
    (and (eq (length a) (length b))
         (cl-every #'nx-test-equal a b)))
   (t (equal a b))))

(defun nx-test-setup ()
  "Create fresh trees for testing."
  (list
   (nx :root (ht (:nx/id 'root)) (list (nx :child (ht (:nx/id 'child) (:prop "value")))))
   (nx :root (ht (:nx/id 'root)) (list (nx :child (ht (:nx/id 'child) (:prop "new-value")))))))

(ert-deftest test-nx-diff-trees-and-apply-diff-prop-change ()
  "Test nx-diff-trees and nx-apply-diff with a property change."
  (let* ((trees (nx-test-setup))
         (tree1 (car trees))
         (tree2 (cadr trees))
         (diff (nx-diff-trees tree1 tree2))
         (applied-tree (nx-apply-diff tree1 diff)))
    (should (= (length diff) 1))
    (should (eq (caar diff) :update))
    (should (nx-test-equal applied-tree tree2))
    (should (not (nx-test-equal tree1 applied-tree)))))

(ert-deftest test-nx-constructor ()
  "Test the nx constructor function."
  (let ((node (nx :div (ht (:class "container")) (list (nx :p (ht) nil)))))
    (should (eq (nx-type node) :div))
    (should (equal (ht-get (nx-props node) :class) "container"))
    (should (= (length (nx-children node)) 1))
    (should (eq (nx-type (car (nx-children node))) :p))))

(ert-deftest test-nx?-valid-node ()
  (should (nx? (nx :div (ht) nil)))
  (should (nx? (nx :div (ht) (list (nx :p (ht) nil)))))
  (should-not (nx? (nx :div (ht) (list (nx :p (ht) "Hello")))))
  (should-error (nx?-strict (ht)) :type 'error)
  (should-error (nx?-strict (nx :div "not a hash table" nil)) :type 'error)
  (should-error (nx?-strict (nx :div (ht) (list (nx :p (ht) "Hello")))) :type 'error))

(ert-deftest test-nx-diff-trees-and-apply-diff-add-child ()
  "Test nx-diff-trees and nx-apply-diff when adding a child node."
  (let* ((existing-child (nx :child (ht (:nx/id "child-1"))))
         (tree1 (nx :root (ht (:nx/id "root-1")) (list existing-child)))
         (new-child (nx :new-child (ht (:prop "value") (:nx/id "child-2"))))
         (tree2 (nx-copy tree1))
         (tree2-children (ht-get tree2 :children)))
    (setf (ht-get tree2 :children) (append tree2-children (list new-child)))
    (let* ((diff (nx-diff-trees tree1 tree2))
           (applied-tree (nx-apply-diff tree1 diff)))
      (should (= (length diff) 1))
      (should (eq (caar diff) :insert))
      (should (equal (cadar diff) "root-1"))
      (should (equal (ht-get (caddr (car diff)) :id) "child-2"))
      (should (nx-test-equal applied-tree tree2))
      (should (not (nx-test-equal tree1 applied-tree))))))

(ert-deftest test-nx-diff-trees-and-apply-diff-remove-child ()
  "Test nx-diff-trees and nx-apply-diff when removing a child node."
  (let* ((tree1 (nx :root (ht (:nx/id 'root)) (list (nx :child1 (ht (:nx/id 'child-1)))
                                     (nx :child2 (ht (:nx/id 'child-2))))))
         (tree2 (nx :root (ht (:nx/id 'root)) (list (nx :child1 (ht (:nx/id 'child-1))))))
         (diff (nx-diff-trees tree1 tree2))
         (applied-tree (nx-apply-diff tree1 diff)))
    (should (= (length diff) 1))
    (should (eq (caar diff) :remove))
    (should (nx-test-equal applied-tree tree2))
    (should (not (nx-test-equal tree1 applied-tree)))))

(ert-deftest test-nx-diff-trees-and-apply-diff-replace-node ()
  "Test nx-diff-trees and nx-apply-diff when replacing a node."
  (let* ((tree1 (nx :root (ht (:nx/id 'root)) (list (nx :old-child (ht (:nx/id 'child) (:prop "same"))))))
         (tree2 (nx :root (ht (:nx/id 'root)) (list (nx :new-child (ht (:nx/id 'child) (:prop "same"))))))
         (diff (nx-diff-trees tree1 tree2))
         (applied-tree (nx-apply-diff tree1 diff)))
    (should (= (length diff) 1))
    (should (eq (caar diff) :replace))
    (should (eq (ht-get (nth 2 (car diff)) :id) 'child))
    (should (ht-equal? (ht (:prop "same")) (ht-get (nth 2 (car diff)) :props)))
    (should (nx-test-equal applied-tree tree2))
    (should (not (nx-test-equal tree1 applied-tree)))))

(ert-deftest test-nx-diff-trees-and-apply-diff-nested-changes ()
  "Test nx-diff-trees and nx-apply-diff with nested changes."
  (let* ((tree1 (nx :root (ht (:nx/id 'root-1))
                    (list (nx :parent (ht (:nx/id 'parent-1))
                              (list (nx :child1 (ht (:nx/id 'child-1) (:prop "old")))
                                    (nx :child2 (ht (:nx/id 'child-2))))))))
         (tree2 (nx :root (ht (:nx/id 'root-1))
                    (list (nx :parent (ht (:nx/id 'parent-1))
                              (list (nx :child1 (ht (:nx/id 'child-1) (:prop "new")))
                                    (nx :child3 (ht (:nx/id 'child-3))))))))
         (diff (nx-diff-trees tree1 tree2))
         (applied-tree (nx-apply-diff tree1 diff)))
    (should (= (length diff) 3))
    (should (member :update (mapcar #'car diff)))
    (should (member :insert (mapcar #'car diff)))
    (should (member :remove (mapcar #'car diff)))
    (should (nx-test-equal applied-tree tree2))
    (should (not (nx-test-equal tree1 applied-tree)))))

(ert-deftest test-nx-diff-trees-and-apply-diff-no-changes ()
  "Test nx-diff-trees and nx-apply-diff when there are no changes."
  (let* ((tree (nx :root (ht) (list (nx :child (ht (:prop "value"))))))
         (diff (nx-diff-trees tree tree))
         (applied-tree (nx-apply-diff tree diff)))
    (should (null diff))
    (should (nx-test-equal applied-tree tree))))

(ert-deftest test-nx-diff-trees-and-apply-diff-complex-structure ()
  "Test nx-diff-trees and nx-apply-diff with a more complex nested structure."
  (let* ((tree1 (nx :root (ht (:nx/id 'root-1))
                    (list (nx :section (ht (:nx/id 'section-1))
                              (list (nx :header (ht (:nx/id 'header-1)) (list (nx :h1 (ht (:nx/id 'h1-1)) nil)))
                                    (nx :content (ht (:nx/id 'content-1)) (list (nx :p (ht (:nx/id 'p-1) (:class "old")) nil)))))
                          (nx :footer (ht (:nx/id 'footer-1)) nil))))
         (tree2 (nx :root (ht (:nx/id 'root-1))
                    (list (nx :section (ht (:nx/id 'section-1))
                              (list (nx :header (ht (:nx/id 'header-1)) (list (nx :h1 (ht (:nx/id 'h1-1)) nil)))
                                    (nx :content (ht (:nx/id 'content-1)) (list (nx :p (ht (:nx/id 'p-1) (:class "new")) nil)
                                                                                (nx :span (ht (:nx/id 'span-2)) nil)))))
                          (nx :nav (ht (:nx/id 'nav-2)) nil))))
         (diff (nx-diff-trees tree1 tree2))
         (applied-tree (nx-apply-diff tree1 diff)))
    (should (= (length diff) 4))
    (should (member :update (-map #'car diff)))
    (should (member :remove (-map #'car diff)))
    (should (= (-count (lambda (x) (eq (car x) :insert)) diff) 2))
    (should (nx-test-equal applied-tree tree2))
    (should (not (nx-test-equal tree1 applied-tree)))))

(ert-deftest test-nx-diff-trees-and-apply-diff-reordered-children ()
  "Test nx-diff-trees and nx-apply-diff with reordered children."
  (let* ((child-a (nx :a (ht (:nx/id 'child-a))))
         (child-b (nx :b (ht (:nx/id 'child-b))))
         (child-c (nx :c (ht (:nx/id 'child-c))))
         (tree1 (nx :root (ht (:nx/id 'root))
                    (list child-a child-b child-c)))
         (tree2 (nx :root (ht (:nx/id 'root))
                    (list child-c child-a child-b)))
         (diff (nx-diff-trees tree1 tree2))
         (applied-tree (nx-apply-diff tree1 diff)))
    (should (= (length diff) 4))
    (should (equal (mapcar #'car diff) '(:remove :remove :insert :insert)))
    (should (nx-test-equal applied-tree tree2))
    (should (not (nx-test-equal tree1 applied-tree)))))

(ert-deftest test-nx-diff-trees-and-apply-diff-nested-reordering ()
  "Test nx-diff-trees and nx-apply-diff with nested reordering of children."
  (let* ((child-a (nx :a (ht (:nx/id 'child-a))))
         (child-b (nx :b (ht (:nx/id 'child-b))))
         (parent1 (nx :parent1 (ht (:nx/id 'parent1)) (list child-a child-b)))
         (parent2 (nx :parent2 (ht (:nx/id 'parent2)) (list child-b child-a)))
         (tree1 (nx :root (ht (:nx/id 'root)) (list parent1 parent2)))
         (tree2 (nx :root (ht (:nx/id 'root)) (list parent2 parent1)))
         (diff (nx-diff-trees tree1 tree2))
         (applied-tree (nx-apply-diff tree1 diff)))
    (should (= (length diff) 2))
    (should (eq (caar diff) :remove))
    (should (eq (caadr diff) :insert))
    (should (equal (cadar diff) 'parent1))
    (should (equal (cadadr diff) 'root))
    (should (equal (ht-get (caddr (cadr diff)) :id) 'parent1))
    (should (nx-test-equal applied-tree tree2))
    (should (not (nx-test-equal tree1 applied-tree)))))

(ert-deftest test-nx-diff-trees-and-apply-diff-mixed-operations ()
  "Test nx-diff-trees and nx-apply-diff with a mix of operations."
  (let* ((tree1 (nx :root (ht (:nx/id 'root))
                    (list (nx :a (ht (:nx/id 'a) (:value 1)))
                          (nx :b (ht (:nx/id 'b)))
                          (nx :c (ht (:nx/id 'c))))))
         (tree2 (nx :root (ht (:nx/id 'root))
                    (list (nx :a (ht (:nx/id 'a) (:value 2)))
                          (nx :d (ht (:nx/id 'd)))
                          (nx :c (ht (:nx/id 'c))))))
         (diff (nx-diff-trees tree1 tree2))
         (applied-tree (nx-apply-diff tree1 diff)))
    (should (= (length diff) 5))
    (should (member :update (mapcar #'car diff)))
    (should (member :remove (mapcar #'car diff)))
    (should (member :insert (mapcar #'car diff)))
    (should (nx-test-equal applied-tree tree2))
    (should (not (nx-test-equal tree1 applied-tree)))))
